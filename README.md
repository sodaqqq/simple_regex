# REGEX

## Вступ

Для цієї лабораторної роботи було використано алгоритм Глушкова (Glushkov's construction algorithm) для перетворення регулярних виразів у недетермінований скінченний автомат (NFA) **без ε-переходів**.

## Алгоритм Глушкова

Основна мета алгоритму - побудувати NFA без ε-переходів.

### Основні кроки:

1. На початку **кожному символу присвоюється унікальний індекс**: `(a+b)*c` → `(a₁ + b₂)*c₃`

2. **Задаємо множини**:
   - **First**: Символи, з яких може починатися вираз
   - **Last**: Символи, якими може закінчуватися вираз
   - **Follow(p)**: Для позиції p, множина позицій, які можуть йти за нею

3. **Побудова NFA**: Стани відповідають позиціям, а переходи визначаються множинами `Follow`

## Реалізація

###  Клас `State` 
Представляє стан автомата.
`transitions`: Словник переходів, де ключ - символ, значення - множина цільових станів.
`is_final`: True, якщо стан є кінцевим.

### Клас `RegexFSM`
Головний клас для побудови автомата.

`def parse_regex(self, regex):` - Розбиває рядок на токен виду (символ, оператор). 
Для прикладу який показаний внизу коду це буде так:
a*4.+hi → `[('a', '*'), ('4', ''), ('.', '+'), ('h', ''), ('i', '')]`

`def compute_nullable(self):` - Визначає чи позиція може бути порожньою.

`def compute_initial_first(self):` - Знаходить перші позиції, з яких може починатися вираз.

`def compute_follow(self):` - Обчислює множину позицій, які можуть слідувати за кожною позицією. Для операторів * і + додає цикл.

## Пояснення імплементації

Алгоритм Глушкова був обраний по кількох причинах. 
Я наткнувся на нього коли читав про **Thompson's construction algorithm**, і вирішив скористатися через відносну простоту а також відстуність ε-стрілок.
Відсутність ε-переходів зменшує кількість станів, і взагалі кількість станів детермінована (тобто завжди буде n+1, де n - довжина виразу).
Він простий в реалізації за допомогою множин first/last/follow, а також не вимагає рекурсивних структур.
